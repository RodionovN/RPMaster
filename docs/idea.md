# RPMaster - Приложение-помощник для мастера настольных ролевых игр

## 1. Название проекта

**RPMaster** - мобильное приложение для управления боями в настольных ролевых играх (D&D 5e и другие системы)

---

## 2. Описание проекта

### Что делает приложение

RPMaster - это специализированное мобильное приложение, разработанное для мастеров настольных ролевых игр (D&D 5e и других систем). Приложение помогает мастеру эффективно управлять боевыми сценами, отслеживая ключевые аспекты боя: порядок хода участников, нанесенный урон, состояния персонажей и монстров, а также предоставляет инструменты для бросков инициативы и урона.

### Зачем нужно приложение

Во время боевых сцен в настольных ролевых играх мастеру приходится одновременно:

-   Отслеживать порядок хода множества участников (игроков и монстров)
-   Ведти учет здоровья каждого участника
-   Помнить о различных эффектах и состояниях
-   Совершать броски кубиков
-   Управлять повествованием и создавать атмосферу

Все это отвлекает от главной задачи мастера - создания увлекательного игрового опыта. RPMaster берет на себя техническую сторону управления боем, позволяя мастеру сосредоточиться на истории и взаимодействии с игроками.

---

## 3. Целевая аудитория

### Основная аудитория

1. **Мастера настольных ролевых игр**

    - Опытные мастера, ведущие регулярные игры
    - Начинающие мастера, которым нужна помощь в организации боевых сцен
    - Мастера, использующие цифровые инструменты для улучшения игрового процесса

2. **Игроки, временно ведущие игры**

    - Игроки, которые иногда берут на себя роль мастера
    - Группы с ротацией мастеров

3. **Группы, использующие цифровые инструменты**
    - Онлайн-игровые группы
    - Гибридные группы (часть участников онлайн, часть офлайн)
    - Группы, предпочитающие цифровые решения бумажным записям

### Целевые платформы

-   **Мобильные устройства (iOS и Android)**: для использования во время игровых сессий
-   **Планшеты**: для более удобного отображения информации и управления боем

---

## 4. Основные функции и возможности

### Фаза 1: Базовый функционал (MVP)

#### 4.1. Управление инициативой

-   **Отслеживание порядка хода**: автоматическое отображение списка участников боя в порядке инициативы (от высшей к низшей)
-   **Визуальная индикация текущего хода**: выделение активного участника
-   **Автоматическое переключение ходов**: переход к следующему участнику по завершении хода
-   **Ручное управление порядком**: возможность изменить порядок хода вручную при необходимости

#### 4.2. Управление участниками боя

-   **Добавление игроков**: возможность добавить персонажей игроков в текущий бой
-   **Добавление монстров**: возможность добавить монстров из библиотеки или создать новых
-   **Удаление участников**: удаление участников из текущего боя
-   **Группировка монстров**: возможность добавить несколько одинаковых монстров одновременно
-   **Визуальное разделение**: четкое визуальное разделение между игроками и монстрами в списке инициативы

#### 4.3. Отслеживание урона

-   **Нанесение урона**: ввод урона для конкретного участника с автоматическим вычитанием из текущего HP
-   **Лечение**: возможность восстановить здоровье участника
-   **Временный урон**: отслеживание временного HP (если применимо)
-   **Визуальная индикация**: цветовая индикация состояния здоровья (здоров, ранен, критически ранен)
-   **Автоматическая проверка смерти**: уведомление, когда HP участника достигает 0 или ниже

#### 4.4. Просмотр информации

-   **Карточки персонажей**: детальный просмотр информации об игроках:
    -   Имя, класс, уровень
    -   Максимальное и текущее HP
    -   Класс брони (AC)
    -   Базовые характеристики (если применимо)
    -   Пассивная восприимчивость (если применимо)
-   **Карточки монстров**: детальный просмотр информации о монстрах:
    -   Название и тип
    -   Максимальное и текущее HP
    -   Класс брони (AC)
    -   Базовые характеристики
    -   Особые способности (если применимо)

#### 4.5. Управление состояниями

-   **Добавление состояний**: возможность добавить эффекты к участникам (отравление, очарование, невидимость, и т.д.)
-   **Удаление состояний**: снятие эффектов с участников
-   **Визуальная индикация**: отображение активных состояний рядом с именем участника
-   **Список стандартных состояний**: предустановленный список распространенных состояний D&D 5e

### Фаза 2: Расширенный функционал

#### 4.6. Генератор бросков

-   **Броски инициативы**: автоматический бросок d20 + модификатор ловкости для всех участников
-   **Броски урона**: генерация урона с настраиваемыми типами кубиков (d4, d6, d8, d10, d12, d20)
-   **Броски атаки**: броски для проверки попадания (d20 + модификатор)
-   **Сохранение бросков**: возможность сохранить результат броска для конкретного участника
-   **История бросков**: отображение последних бросков в текущем бою

#### 4.7. Режим реальных кубиков

-   **Переключение режима**: возможность включить/выключить генератор бросков в настройках
-   **Ручной ввод результатов**: когда генератор выключен, возможность вручную ввести результат броска кубиков
-   **Гибкость использования**: поддержка как цифровых, так и физических кубиков по выбору мастера

#### 4.8. Импорт данных

-   **Импорт игроков**: загрузка информации о персонажах игроков из JSON файла
-   **Импорт монстров**: загрузка информации о монстрах из JSON файла
-   **Валидация данных**: проверка корректности структуры загружаемых данных
-   **Обработка ошибок**: информативные сообщения об ошибках при некорректном формате данных
-   **Массовый импорт**: возможность загрузить несколько персонажей или монстров одновременно

#### 4.9. Сохранение сессий

-   **Сохранение текущего боя**: возможность сохранить состояние текущего боя для продолжения позже
-   **Список сохраненных боев**: просмотр и загрузка ранее сохраненных боевых сцен
-   **Автосохранение**: автоматическое сохранение прогресса (опционально)

### Фаза 3: Дополнительные возможности

#### 4.10. История и логирование

-   **История бросков**: полный лог всех бросков в текущем бою с временными метками
-   **История действий**: запись основных действий (нанесение урона, применение состояний, и т.д.)
-   **Экспорт логов**: возможность экспортировать историю боя в текстовый формат

#### 4.11. Таймеры и эффекты

-   **Таймеры состояний**: автоматический отсчет времени для временных эффектов
-   **Уведомления**: напоминания о истечении времени эффектов
-   **Настраиваемые длительности**: возможность задать длительность эффекта в раундах или минутах

#### 4.12. Статистика и аналитика

-   **Статистика боя**: общий урон, количество раундов, средний урон за раунд
-   **Статистика участников**: индивидуальная статистика по каждому участнику
-   **Визуализация данных**: простые графики и диаграммы боевой статистики

#### 4.13. Персонализация

-   **Темная тема**: поддержка темной и светлой темы оформления
-   **Настройки отображения**: возможность настроить, какая информация отображается в списке инициативы
-   **Цветовые схемы**: настройка цветов для различных состояний и типов участников

---

## 5. Технологии и подходы

### 5.1. React Native

**Почему используется:**

-   Кроссплатформенная разработка позволяет создать одно приложение для iOS и Android
-   Использование нативного JavaScript/TypeScript упрощает разработку
-   Большое сообщество и обширная экосистема библиотек
-   Возможность использования существующих навыков веб-разработки

**Как применяется:**

-   Использование компонентов React Native (View, Text, Button, ScrollView, FlatList, и т.д.) для создания нативного UI
-   Применение StyleSheet для стилизации компонентов
-   Использование платформо-специфичных компонентов при необходимости (Platform.OS)
-   Настройка навигации и роутинга через React Navigation

### 5.2. Управление состоянием

**Технологии:**

-   **React Context API** (для небольших/средних проектов) или **Redux Toolkit** (для более сложных сценариев)
-   **Zustand** (альтернативный легковесный вариант)

**Почему используется:**

-   Централизованное управление состоянием боя, участников, урона и настроек
-   Предсказуемое обновление UI при изменении данных
-   Упрощение передачи данных между компонентами
-   Возможность отладки состояния через инструменты разработчика

**Как применяется:**

-   Создание глобального хранилища (Context/Store) для данных о:
    -   Текущем бое (список участников, порядок инициативы, текущий ход)
    -   Игроках (библиотека загруженных персонажей)
    -   Монстрах (библиотека загруженных монстров)
    -   Настройках приложения (включен ли генератор бросков, тема оформления)
-   Использование хуков (useContext, useSelector) для доступа к состоянию в компонентах
-   Создание actions/reducers для обновления состояния (добавление участника, нанесение урона, и т.д.)

### 5.3. Навигация

**Технология:**

-   **React Navigation** (v6)

**Почему используется:**

-   Стандартное решение для навигации в React Native приложениях
-   Поддержка различных типов навигации (стековая, табовая, drawer)
-   Интеграция с системной навигацией iOS и Android
-   Поддержка глубоких ссылок и параметров маршрутов

**Как применяется:**

-   **Stack Navigator**: для основной навигации между экранами:
    -   Экран списка активных/сохраненных боев
    -   Экран активного боя (главный экран с инициативой)
    -   Экран просмотра карточки персонажа/монстра
    -   Экран импорта данных
    -   Экран настроек
-   **Tab Navigator** (опционально): для быстрого доступа к основным разделам
-   Передача параметров между экранами (например, ID персонажа для просмотра деталей)

### 5.4. Хранение данных

**Технологии:**

-   **AsyncStorage** (встроенное решение React Native) или **React Native MMKV** (более производительная альтернатива)
-   **SQLite** (для более сложных запросов, если потребуется в будущем)

**Почему используется:**

-   Локальное хранение данных на устройстве без необходимости подключения к интернету
-   Сохранение данных между сессиями приложения
-   Быстрый доступ к сохраненным данным

**Как применяется:**

-   Сохранение библиотеки игроков и монстров в локальном хранилище
-   Сохранение состояния текущего боя для возможности продолжения позже
-   Сохранение настроек приложения (тема, включен ли генератор бросков)
-   Загрузка сохраненных данных при запуске приложения
-   Использование ключей для организации данных (например, 'players', 'monsters', 'currentBattle', 'settings')

### 5.5. Работа с JSON

**Технологии:**

-   Встроенные методы JavaScript: **JSON.parse()** и **JSON.stringify()**
-   Библиотека валидации (опционально): **Zod** или **Yup** для валидации структуры данных

**Почему используется:**

-   Стандартный формат для обмена данными
-   Простота импорта/экспорта данных
-   Человекочитаемый формат для ручного редактирования
-   Широкая поддержка в различных инструментах

**Как применяется:**

-   **Импорт данных**:
    -   Использование библиотеки для выбора файлов (например, `react-native-document-picker`)
    -   Чтение содержимого файла
    -   Парсинг JSON с помощью JSON.parse()
    -   Валидация структуры данных (проверка наличия обязательных полей)
    -   Сохранение валидных данных в локальное хранилище
-   **Экспорт данных**:
    -   Получение данных из хранилища
    -   Преобразование в JSON с помощью JSON.stringify()
    -   Сохранение в файл или предоставление для скачивания
-   **Обработка ошибок**: try-catch блоки для обработки некорректного JSON и информативные сообщения об ошибках

### 5.6. Генерация случайных чисел и бросков кубиков

**Технологии:**

-   Встроенный **Math.random()** для базовой генерации
-   Библиотека для кубиков (опционально): **dice-roller** или **rpg-dice-roller** для более сложных бросков

**Почему используется:**

-   Реализация бросков инициативы и урона
-   Эмуляция физических кубиков
-   Поддержка различных типов кубиков (d4, d6, d8, d10, d12, d20, d100)

**Как применяется:**

-   **Функция генерации броска кубика**:
    ```javascript
    function rollDice(sides, modifier = 0) {
        return Math.floor(Math.random() * sides) + 1 + modifier;
    }
    ```
-   **Броски инициативы**: d20 + модификатор ловкости для каждого участника
-   **Броски урона**: генерация урона на основе формулы (например, "2d6+3")
-   **Визуализация результатов**: отображение результата броска с разбивкой (например, "15 (12 + 3)")
-   **История бросков**: сохранение результатов для отображения в истории

### 5.7. Дополнительные библиотеки и инструменты

**UI компоненты:**

-   **React Native Paper** или **NativeBase** (опционально): готовые компоненты для ускорения разработки UI
-   **React Native Vector Icons**: иконки для улучшения визуального интерфейса

**Утилиты:**

-   **Lodash** (опционально): полезные функции для работы с массивами и объектами
-   **Date-fns**: работа с датами и временем (для истории и таймеров)

**Разработка:**

-   **TypeScript** (рекомендуется): типизация для уменьшения ошибок и улучшения разработки
-   **ESLint** и **Prettier**: поддержание качества кода

---

## 6. План развития проекта по модулям

### Модуль 1: Основы React Native и настройка проекта

**Цель модуля:** Создать базовую структуру проекта и статический интерфейс приложения.

**Что реализуем:**

-   Инициализация проекта React Native (через `npx react-native init` или Expo)
-   Настройка структуры папок проекта
-   Создание базовых компонентов:
    -   Компонент списка участников боя
    -   Компонент карточки участника
    -   Компонент кнопок действий
-   Стилизация с помощью StyleSheet
-   Создание статического экрана со списком участников (игроков и монстров)
-   Базовый макет экрана боя

**Результат:**
Статический интерфейс приложения с отображением списка игроков и монстров. Пользователь может видеть структуру приложения, но функциональность еще не работает.

**Ключевые файлы:**

-   `App.tsx` - главный компонент приложения
-   `src/components/ParticipantList.tsx` - компонент списка участников
-   `src/components/ParticipantCard.tsx` - компонент карточки участника
-   `src/screens/BattleScreen.tsx` - экран боя

---

### Модуль 2: Управление состоянием

**Цель модуля:** Реализовать динамическое управление данными о бое и участниках.

**Что реализуем:**

-   Настройка Context API или Redux Toolkit для управления состоянием
-   Создание хранилища (Context/Store) для данных:
    -   Текущий бой (список участников, порядок инициативы)
    -   Библиотека игроков
    -   Библиотека монстров
-   Создание actions/reducers для:
    -   Добавления участника в бой
    -   Удаления участника из боя
    -   Обновления HP участника (нанесение урона, лечение)
    -   Добавления/удаления состояний
-   Интеграция компонентов с состоянием через хуки (useContext, useSelector)
-   Реализация функций добавления/удаления участников через UI

**Результат:**
Динамическое управление участниками боя. Пользователь может добавлять и удалять участников, наносить урон и лечить их. Данные обновляются в реальном времени.

**Ключевые файлы:**

-   `src/context/BattleContext.tsx` или `src/store/battleSlice.ts` - хранилище состояния боя
-   `src/context/PlayersContext.tsx` - хранилище игроков
-   `src/context/MonstersContext.tsx` - хранилище монстров
-   Обновление компонентов для использования состояния

---

### Модуль 3: Навигация между экранами

**Цель модуля:** Организовать навигацию между различными экранами приложения.

**Что реализуем:**

-   Установка и настройка React Navigation
-   Создание структуры навигации (Stack Navigator):
    -   Экран главного меню / списка боев
    -   Экран активного боя (главный экран)
    -   Экран просмотра карточки персонажа/монстра
    -   Экран импорта данных
    -   Экран настроек
-   Реализация переходов между экранами
-   Передача параметров между экранами (например, ID персонажа)
-   Настройка заголовков экранов и кнопок навигации

**Результат:**
Полноценная навигация между экранами приложения. Пользователь может переходить между разными разделами приложения, просматривать детальную информацию о персонажах и монстрах.

**Ключевые файлы:**

-   `src/navigation/AppNavigator.tsx` - главный навигатор
-   `src/screens/HomeScreen.tsx` - экран главного меню
-   `src/screens/BattleScreen.tsx` - экран боя
-   `src/screens/CharacterDetailScreen.tsx` - экран деталей персонажа
-   `src/screens/ImportScreen.tsx` - экран импорта
-   `src/screens/SettingsScreen.tsx` - экран настроек

---

### Модуль 4: Работа с данными и локальное хранение

**Цель модуля:** Реализовать сохранение и загрузку данных приложения.

**Что реализуем:**

-   Интеграция AsyncStorage или React Native MMKV
-   Создание сервисов для работы с хранилищем:
    -   Сохранение библиотеки игроков
    -   Сохранение библиотеки монстров
    -   Сохранение текущего состояния боя
    -   Сохранение настроек приложения
-   Загрузка данных при запуске приложения
-   Реализация экрана импорта данных:
    -   Выбор JSON файла с устройства
    -   Парсинг JSON данных
    -   Валидация структуры данных
    -   Сохранение валидных данных
-   Обработка ошибок при загрузке и парсинге данных
-   Создание примеров JSON файлов для тестирования

**Результат:**
Возможность загружать данные об игроках и монстрах из JSON файлов и сохранять их локально. Данные сохраняются между сессиями приложения.

**Ключевые файлы:**

-   `src/services/StorageService.ts` - сервис для работы с хранилищем
-   `src/services/ImportService.ts` - сервис для импорта данных
-   `src/utils/jsonValidator.ts` - валидация JSON структуры
-   `src/screens/ImportScreen.tsx` - экран импорта (обновление)
-   Примеры JSON файлов в `examples/`

---

### Модуль 5: Интерактивность и игровая логика

**Цель модуля:** Реализовать основную игровую логику управления боем.

**Что реализуем:**

-   Реализация генератора бросков кубиков:
    -   Функции для бросков различных типов кубиков (d4, d6, d8, d10, d12, d20, d100)
    -   Функция для сложных бросков (например, "2d6+3")
    -   Визуализация результатов бросков
-   Реализация системы инициативы:
    -   Автоматический бросок инициативы для всех участников
    -   Сортировка участников по инициативе
    -   Определение текущего хода
    -   Переключение между ходами участников
-   Улучшение системы управления уроном:
    -   Валидация ввода урона
    -   Обработка смерти персонажей (HP <= 0)
    -   Отслеживание максимального и текущего HP
-   Расширение системы состояний:
    -   Предустановленный список состояний D&D 5e
    -   Визуальная индикация состояний
    -   Управление множественными состояниями
-   Реализация UI для всех игровых действий:
    -   Кнопки для бросков инициативы и урона
    -   Формы для ввода урона и лечения
    -   Интерфейс для управления состояниями

**Результат:**
Полнофункциональная система управления боем. Пользователь может проводить боевые сцены: бросать инициативу, отслеживать ходы, наносить урон, применять состояния.

**Ключевые файлы:**

-   `src/utils/diceRoller.ts` - функции для бросков кубиков
-   `src/utils/initiative.ts` - логика расчета инициативы
-   `src/components/DiceRoller.tsx` - компонент генератора бросков
-   `src/components/DamageInput.tsx` - компонент ввода урона
-   `src/components/ConditionManager.tsx` - компонент управления состояниями
-   Обновление `BattleScreen.tsx` с новой функциональностью

---

### Модуль 6: Продвинутые возможности и полировка

**Цель модуля:** Добавить дополнительные функции и улучшить пользовательский опыт.

**Что реализуем:**

-   Реализация настроек приложения:
    -   Переключение генератора бросков (включен/выключен)
    -   Выбор темы оформления (светлая/темная)
    -   Настройки отображения информации
-   Реализация темной темы:
    -   Создание цветовых схем для светлой и темной темы
    -   Переключение между темами
    -   Сохранение выбранной темы
-   Добавление анимаций:
    -   Плавные переходы между ходами участников
    -   Анимации при добавлении/удалении участников
    -   Визуальная обратная связь при действиях
-   Реализация истории бросков:
    -   Сохранение всех бросков в текущем бою
    -   Отображение истории с временными метками
    -   Очистка истории
-   Реализация экспорта данных:
    -   Экспорт текущего состояния боя в JSON
    -   Экспорт библиотеки игроков/монстров
-   Улучшение UI/UX:
    -   Оптимизация для планшетов (адаптивный дизайн)
    -   Улучшение визуальной иерархии
    -   Добавление иконок и визуальных индикаторов
    -   Обработка edge cases и улучшение обработки ошибок

**Результат:**
Полированное приложение с дополнительными функциями, улучшенным пользовательским интерфейсом и настройками персонализации.

**Ключевые файлы:**

-   `src/context/SettingsContext.tsx` - хранилище настроек
-   `src/theme/colors.ts` - цветовые схемы для тем
-   `src/components/HistoryPanel.tsx` - компонент истории бросков
-   `src/services/ExportService.ts` - сервис экспорта данных
-   `src/screens/SettingsScreen.tsx` - экран настроек (обновление)
-   Обновление всех компонентов для поддержки тем

---

### Модуль 7: Оптимизация, тестирование и финализация

**Цель модуля:** Обеспечить стабильность, производительность и качество приложения.

**Что реализуем:**

-   Оптимизация производительности:
    -   Мемоизация компонентов (React.memo, useMemo, useCallback)
    -   Оптимизация рендеринга списков (FlatList с правильными ключами)
    -   Ленивая загрузка данных
    -   Оптимизация работы с хранилищем
-   Обработка ошибок:
    -   Глобальная обработка ошибок
    -   Информативные сообщения об ошибках для пользователя
    -   Логирование ошибок для отладки
-   Валидация данных:
    -   Валидация всех пользовательских вводов
    -   Защита от некорректных данных
    -   Валидация JSON при импорте
-   Тестирование:
    -   Unit тесты для критических функций (броски кубиков, расчет инициативы)
    -   Интеграционные тесты для основных сценариев использования
    -   Тестирование на различных устройствах и размерах экранов
-   Документация:
    -   Комментарии в коде
    -   README с инструкциями по установке и использованию
    -   Документация формата JSON для импорта данных
-   Подготовка к релизу:
    -   Настройка иконки приложения
    -   Настройка splash screen
    -   Оптимизация размера приложения
    -   Подготовка к публикации в App Store и Google Play

**Результат:**
Стабильное, оптимизированное и готовое к использованию приложение с хорошей производительностью и надежной обработкой ошибок.

**Ключевые файлы:**

-   `src/utils/errorHandler.ts` - обработка ошибок
-   `__tests__/` - директория с тестами
-   `README.md` - документация проекта
-   `docs/json-format.md` - документация формата JSON
-   Обновление всех компонентов для оптимизации

---

## 7. Будущие расширения и развитие проекта

### Краткосрочные расширения (после MVP)

1. **Таймеры для эффектов**

    - Автоматический отсчет времени для временных состояний
    - Уведомления об истечении эффектов
    - Настройка длительности в раундах или минутах

2. **Расширенная статистика**

    - Подсчет общего урона в бою
    - Статистика по каждому участнику
    - Количество раундов боя
    - Простые графики и визуализация данных

3. **Улучшенная библиотека монстров**
    - Встроенная база данных монстров D&D 5e
    - Поиск и фильтрация монстров
    - Категоризация по типу, уровню опасности (CR)

### Среднесрочные расширения

4. **Создание и редактирование персонажей/монстров**

    - Редактор для создания собственных персонажей и монстров
    - Сохранение созданных сущностей в библиотеку
    - Импорт/экспорт созданных данных

5. **Интеграция с внешними API**

    - Загрузка данных о монстрах из D&D 5e API
    - Интеграция с популярными инструментами для мастеров
    - Синхронизация данных между устройствами

6. **Мультиплеер и синхронизация**
    - Синхронизация боя между несколькими устройствами через локальную сеть
    - Режим "мастер + помощники" для распределения управления
    - Облачная синхронизация для доступа с разных устройств

### Долгосрочные расширения

7. **Расширенная визуализация**

    - Графики урона по времени
    - Диаграммы распределения инициативы
    - Визуализация эффективности действий

8. **Голосовые команды**

    - Управление боем голосовыми командами
    - Распознавание речи для быстрого ввода данных
    - Интеграция с голосовыми ассистентами

9. **Экспорт отчетов**

    - Создание PDF отчетов о боевой сессии
    - Детальная статистика и анализ боя
    - Экспорт в различные форматы для ведения записей

10. **Поддержка других систем RPG**

    - Адаптация под Pathfinder, GURPS, и другие системы
    - Настраиваемые правила для разных систем
    - Универсальный режим для кастомных систем

11. **Интеграция с картами и миниатюрами**
    - Отображение позиций на карте
    - Управление расстояниями и зонами эффектов
    - Интеграция с виртуальными столами

---

## 8. Структура JSON для импорта данных

### 8.1. Формат данных игрока (Player)

```json
{
    "name": "Арагорн",
    "class": "Воин",
    "level": 5,
    "maxHP": 50,
    "currentHP": 45,
    "armorClass": 16,
    "initiativeModifier": 2,
    "conditions": [],
    "notes": "Лидер группы"
}
```

**Описание полей:**

-   `name` (string, обязательное) - имя персонажа
-   `class` (string, опциональное) - класс персонажа
-   `level` (number, опциональное) - уровень персонажа
-   `maxHP` (number, обязательное) - максимальное здоровье
-   `currentHP` (number, обязательное) - текущее здоровье
-   `armorClass` (number, обязательное) - класс брони (AC)
-   `initiativeModifier` (number, опциональное, по умолчанию 0) - модификатор инициативы
-   `conditions` (array, опциональное) - массив активных состояний
-   `notes` (string, опциональное) - дополнительные заметки

### 8.2. Формат данных монстра (Monster)

```json
{
    "name": "Гоблин",
    "type": "Гуманоид",
    "challengeRating": 0.25,
    "maxHP": 7,
    "currentHP": 7,
    "armorClass": 15,
    "initiativeModifier": 2,
    "conditions": [],
    "specialAbilities": ["Нимбовые атаки"],
    "notes": "Стандартный гоблин из Monster Manual"
}
```

**Описание полей:**

-   `name` (string, обязательное) - название монстра
-   `type` (string, опциональное) - тип монстра
-   `challengeRating` (number, опциональное) - уровень опасности (CR)
-   `maxHP` (number, обязательное) - максимальное здоровье
-   `currentHP` (number, обязательное) - текущее здоровье
-   `armorClass` (number, обязательное) - класс брони (AC)
-   `initiativeModifier` (number, опциональное, по умолчанию 0) - модификатор инициативы
-   `conditions` (array, опциональное) - массив активных состояний
-   `specialAbilities` (array, опциональное) - массив особых способностей
-   `notes` (string, опциональное) - дополнительные заметки

### 8.3. Формат для массового импорта игроков

```json
{
    "players": [
        {
            "name": "Арагорн",
            "class": "Воин",
            "level": 5,
            "maxHP": 50,
            "currentHP": 50,
            "armorClass": 16,
            "initiativeModifier": 2
        },
        {
            "name": "Гэндальф",
            "class": "Волшебник",
            "level": 5,
            "maxHP": 35,
            "currentHP": 35,
            "armorClass": 12,
            "initiativeModifier": 1
        }
    ]
}
```

### 8.4. Формат для массового импорта монстров

```json
{
    "monsters": [
        {
            "name": "Гоблин",
            "type": "Гуманоид",
            "maxHP": 7,
            "currentHP": 7,
            "armorClass": 15,
            "initiativeModifier": 2
        },
        {
            "name": "Орк",
            "type": "Гуманоид",
            "maxHP": 15,
            "currentHP": 15,
            "armorClass": 13,
            "initiativeModifier": 1
        }
    ]
}
```

### 8.5. Стандартные состояния (Conditions) D&D 5e

Список предустановленных состояний, которые можно применять к участникам:

-   Отравлен (Poisoned)
-   Очарован (Charmed)
-   Испуган (Frightened)
-   Оглушен (Stunned)
-   Обездвижен (Paralyzed)
-   Невидим (Invisible)
-   Невидимый (Invisible)
-   Несознательный (Unconscious)
-   Исчерпан (Exhausted)
-   Сбит с ног (Prone)
-   Ограничен (Restrained)
-   Окаменел (Petrified)
-   Ослеплен (Blinded)
-   Глух (Deafened)
-   Очарован (Charmed)

---

## 9. Заключение

RPMaster - это комплексное решение для мастеров настольных ролевых игр, которое значительно упрощает управление боевыми сценами. Приложение развивается поэтапно, начиная с базового функционала и постепенно добавляя расширенные возможности.

Проект построен на современных технологиях React Native, что обеспечивает кроссплатформенность и возможность использования на различных устройствах. Модульная структура разработки позволяет постепенно добавлять функциональность и тестировать каждую часть отдельно.

План развития проекта охватывает все этапы от создания базового интерфейса до оптимизации и подготовки к релизу, а также включает перспективные направления для будущего расширения функциональности.
